# Terragrunt Configuration File
# This file demonstrates key Terragrunt blocks and their usage.
# Terragrunt is a thin wrapper for Terraform that provides extra tools for:
# - Keeping configurations DRY (Don't Repeat Yourself)
# - Working with multiple Terraform modules
# - Managing remote state
# - Locking state files
# - Generating Terraform code dynamically

# remote_state Block
# The remote_state block configures where Terraform state is stored.
# This is crucial for collaboration and state management.
# Supported backends include: azurerm, s3, gcs, etc.
# For Azure, we use azurerm backend which stores state in Azure Storage Account.
remote_state {
  backend = "azurerm"
  config = {
    # Azure subscription ID where the storage account resides
    subscription_id      = "REPLACE_WITH_YOUR_SUBSCRIPTION_ID"
    # Resource group containing the storage account
    resource_group_name  = "REPLACE_WITH_YOUR_RESOURCE_GROUP_NAME"
    # Name of the Azure Storage Account
    storage_account_name = "REPLACE_WITH_YOUR_STR_ACC_NAME"
    # Container within the storage account
    container_name       = "REPLACE_WITH_YOUR_STR_ACC_CONTAINER_NAME"
    # Key (path) for the state file. Uses Terragrunt function to make it relative
    key                  = "${path_relative_to_include()}/terragrunt.tfstate"
  }
}

# include Block
# The include block allows you to include configurations from parent directories.
# This enables hierarchical configuration inheritance.
# Uncomment the following to include root.hcl from parent directories.
# This is commonly used to share common configurations across environments.
# include {
#   path = find_in_parent_folders("root.hcl")
# }

# generate Block
# The generate block allows Terragrunt to dynamically generate Terraform code.
# This is useful for creating provider configurations, backend configs, etc.
# The generated file will be placed in the same directory as this terragrunt.hcl
generate "provider" {
  # Path where the generated file will be created
  path      = "provider.tf"
  # Action if file exists: overwrite, skip, or error
  if_exists = "overwrite"
  # Contents of the generated file (Terraform HCL)
  contents  = <<EOF
# This provider.tf is auto-generated by Terragrunt
# It configures the Azure provider and sets up the backend
provider "azurerm" {
  features {}
  subscription_id = "REPLACE_WITH_YOUR_SUBSCRIPTION_ID"
}
terraform {
  backend "azurerm" {}
}
EOF
}

# Additional Terragrunt Blocks (Commented for Reference)

# inputs Block
# The inputs block allows you to pass variables to child modules.
# This is useful for overriding default values or providing environment-specific configs.
# inputs = {
#   environment = "dev"
#   location    = "East US"
# }

# dependencies Block
# The dependencies block allows you to specify dependencies between modules.
# Terragrunt will ensure dependent modules are applied in the correct order.
# dependencies {
#   paths = ["../vpc", "../security-groups"]
# }

# terraform Block
# The terraform block allows you to override Terraform settings.
# This can include version constraints, required providers, etc.
# terraform {
#   extra_arguments "common_vars" {
#     commands = ["plan", "apply"]
#     arguments = [
#       "-var-file=../../common.tfvars"
#     ]
#   }
# }

# locals Block
# The locals block allows you to define local values that can be reused.
# Similar to Terraform locals, but at the Terragrunt level.
# locals {
#   common_tags = {
#     Environment = "dev"
#     Project     = "my-project"
#   }
# }

# Usage Notes:
# - Run 'terragrunt plan' to see what changes will be made
# - Run 'terragrunt apply' to apply the changes
# - Run 'terragrunt destroy' to destroy the infrastructure
# - Terragrunt automatically handles state locking and unlocking
# - Use 'terragrunt plan --all' to plan across multiple modules
# - Use 'terragrunt apply --all' to apply across multiple modules
